<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë„ë©´ ê·¸ë¦¬ê¸° - ê²©ì ë²½ ë“œë˜ê·¸ ì—ë””í„°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .toolbar {
            background-color: #34495e;
            padding: 10px;
            display: flex;
            gap: 15px;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .tool-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .tool-btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .tool-btn:hover {
            background-color: #2980b9;
        }

        .tool-btn.active {
            background-color: #e74c3c;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: auto;
        }

        #drawingCanvas {
            border: 2px solid #2c3e50;
            background-color: white;
            cursor: crosshair;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .info-panel {
            background-color: #ecf0f1;
            padding: 10px;
            border-top: 1px solid #bdc3c7;
            font-size: 12px;
            color: #7f8c8d;
        }

        label {
            color: #ecf0f1;
            margin-right: 10px;
        }

        input[type="range"] {
            width: 100px;
        }

        input[type="color"] {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        .grid-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ  ë„ë©´ ê·¸ë¦¬ê¸° - ê²©ì ë²½ ë“œë˜ê·¸ ì—ë””í„°</h1>
    </div>
    
    <div class="toolbar">
        <div class="tool-group">
            <button id="wallTool" class="tool-btn active">ğŸ§± ë²½ ê·¸ë¦¬ê¸°</button>
            <button id="eraseTool" class="tool-btn">ğŸ§¹ ì§€ìš°ê¸°</button>
            <button id="clearTool" class="tool-btn">ğŸ—‘ï¸ ì „ì²´ ì§€ìš°ê¸°</button>
        </div>
        
        <div class="tool-group">
            <label for="wallColor">ë²½ ìƒ‰ìƒ:</label>
            <input type="color" id="wallColor" value="#2c3e50">
        </div>
        
        <div class="tool-group grid-controls">
            <label for="gridSize">ê²©ì í¬ê¸°:</label>
            <input type="range" id="gridSize" min="10" max="50" value="20">
            <span id="gridSizeValue">20px</span>
        </div>
        
        <div class="tool-group">
            <label for="wallWidth">ë²½ ë‘ê»˜:</label>
            <input type="range" id="wallWidth" min="2" max="10" value="4">
            <span id="wallWidthValue">4px</span>
        </div>
        
        <div class="tool-group">
            <button id="templateBtn" class="tool-btn">ğŸ“‹ í…œí”Œë¦¿</button>
            <button id="saveBtn" class="tool-btn">ğŸ’¾ ì €ì¥</button>
        </div>
    </div>
    
    <div class="canvas-container">
        <canvas id="drawingCanvas" width="800" height="600"></canvas>
    </div>
    
    <div class="info-panel">
        ë§ˆìš°ìŠ¤ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ë²½ì„ ê·¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê²©ìì— ë§ì¶° ìë™ìœ¼ë¡œ ì •ë ¬ë©ë‹ˆë‹¤. | ë„êµ¬: ë²½ ê·¸ë¦¬ê¸°/ì§€ìš°ê¸° | ì»¨íŠ¸ë¡¤: ê²©ì í¬ê¸°, ë²½ ìƒ‰ìƒ, ë²½ ë‘ê»˜ ì¡°ì ˆ ê°€ëŠ¥
    </div>

    <script>
        class FloorPlanEditor {
            constructor() {
                this.canvas = document.getElementById('drawingCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gridSize = 20;
                this.wallWidth = 4;
                this.wallColor = '#2c3e50';
                this.currentTool = 'wall';
                
                this.isDrawing = false;
                this.startPoint = null;
                this.walls = [];
                this.previewWall = null;
                
                this.initializeEventListeners();
                this.drawGrid();
            }
            
            initializeEventListeners() {
                // ìº”ë²„ìŠ¤ ì´ë²¤íŠ¸
                this.canvas.addEventListener('mousedown', this.startDrawing.bind(this));
                this.canvas.addEventListener('mousemove', this.draw.bind(this));
                this.canvas.addEventListener('mouseup', this.stopDrawing.bind(this));
                this.canvas.addEventListener('mouseleave', this.stopDrawing.bind(this));
                
                // ë„êµ¬ ë²„íŠ¼
                document.getElementById('wallTool').addEventListener('click', () => this.setTool('wall'));
                document.getElementById('eraseTool').addEventListener('click', () => this.setTool('erase'));
                document.getElementById('clearTool').addEventListener('click', () => this.clearCanvas());
                
                // ì»¨íŠ¸ë¡¤
                document.getElementById('gridSize').addEventListener('input', this.updateGridSize.bind(this));
                document.getElementById('wallWidth').addEventListener('input', this.updateWallWidth.bind(this));
                document.getElementById('wallColor').addEventListener('change', this.updateWallColor.bind(this));
                
                // ê¸°íƒ€ ë²„íŠ¼
                document.getElementById('templateBtn').addEventListener('click', () => this.loadTemplate());
                document.getElementById('saveBtn').addEventListener('click', () => this.saveDrawing());
            }
            
            snapToGrid(x, y) {
                return {
                    x: Math.round(x / this.gridSize) * this.gridSize,
                    y: Math.round(y / this.gridSize) * this.gridSize
                };
            }
            
            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            startDrawing(e) {
                if (this.currentTool === 'wall') {
                    this.isDrawing = true;
                    const mousePos = this.getMousePos(e);
                    this.startPoint = this.snapToGrid(mousePos.x, mousePos.y);
                } else if (this.currentTool === 'erase') {
                    const mousePos = this.getMousePos(e);
                    this.eraseWall(mousePos.x, mousePos.y);
                }
            }
            
            draw(e) {
                if (this.currentTool === 'wall' && this.isDrawing && this.startPoint) {
                    const mousePos = this.getMousePos(e);
                    const endPoint = this.snapToGrid(mousePos.x, mousePos.y);
                    
                    // ìˆ˜ì§ ë˜ëŠ” ìˆ˜í‰ì„ ë§Œ ê·¸ë¦¬ê¸°
                    if (Math.abs(endPoint.x - this.startPoint.x) > Math.abs(endPoint.y - this.startPoint.y)) {
                        endPoint.y = this.startPoint.y; // ìˆ˜í‰ì„ 
                    } else {
                        endPoint.x = this.startPoint.x; // ìˆ˜ì§ì„ 
                    }
                    
                    this.previewWall = {
                        start: this.startPoint,
                        end: endPoint,
                        color: this.wallColor,
                        width: this.wallWidth
                    };
                    
                    this.redraw();
                }
            }
            
            stopDrawing() {
                if (this.isDrawing && this.previewWall) {
                    // ê¸¸ì´ê°€ ìˆëŠ” ë²½ë§Œ ì¶”ê°€
                    if (this.previewWall.start.x !== this.previewWall.end.x || 
                        this.previewWall.start.y !== this.previewWall.end.y) {
                        
                        // ì¤‘ë³µ ë²½ ì²´í¬
                        if (!this.isDuplicateWall(this.previewWall)) {
                            this.walls.push({...this.previewWall});
                        }
                    }
                }
                
                this.isDrawing = false;
                this.startPoint = null;
                this.previewWall = null;
                this.redraw();
            }
            
            eraseWall(x, y) {
                for (let i = this.walls.length - 1; i >= 0; i--) {
                    const wall = this.walls[i];
                    if (this.isPointOnWall(x, y, wall)) {
                        this.walls.splice(i, 1);
                        break;
                    }
                }
                this.redraw();
            }
            
            isDuplicateWall(newWall) {
                return this.walls.some(existingWall => {
                    // ê°™ì€ ì‹œì‘ì ê³¼ ëì  (ì–‘ë°©í–¥ ì²´í¬)
                    return (
                        (existingWall.start.x === newWall.start.x && 
                         existingWall.start.y === newWall.start.y &&
                         existingWall.end.x === newWall.end.x && 
                         existingWall.end.y === newWall.end.y) ||
                        (existingWall.start.x === newWall.end.x && 
                         existingWall.start.y === newWall.end.y &&
                         existingWall.end.x === newWall.start.x && 
                         existingWall.end.y === newWall.start.y)
                    );
                });
            }

            isPointOnWall(x, y, wall) {
                const tolerance = this.wallWidth + 5;
                const dx = wall.end.x - wall.start.x;
                const dy = wall.end.y - wall.start.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length === 0) return false;
                
                const dot = ((x - wall.start.x) * dx + (y - wall.start.y) * dy) / (length * length);
                
                if (dot < 0 || dot > 1) return false;
                
                const projX = wall.start.x + dot * dx;
                const projY = wall.start.y + dot * dy;
                const distance = Math.sqrt((x - projX) * (x - projX) + (y - projY) * (y - projY));
                
                return distance <= tolerance;
            }
            
            drawGrid() {
                // ê²©ìëŠ” ì˜¤ì§ í™”ë©´ í‘œì‹œìš©ì´ë©° walls ë°°ì—´ì—ëŠ” ì ˆëŒ€ ì €ì¥ë˜ì§€ ì•ŠìŒ
                this.ctx.save(); // í˜„ì¬ ìƒíƒœ ì €ì¥
                this.ctx.strokeStyle = '#ecf0f1';
                this.ctx.lineWidth = 0.5;
                this.ctx.globalAlpha = 0.3; // ê²©ìë¥¼ ë” ì—°í•˜ê²Œ
                
                // ì„¸ë¡œì„ 
                for (let x = 0; x <= this.canvas.width; x += this.gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                // ê°€ë¡œì„ 
                for (let y = 0; y <= this.canvas.height; y += this.gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
                
                this.ctx.restore(); // ì´ì „ ìƒíƒœ ë³µì›
            }
            
            drawWall(wall) {
                this.ctx.strokeStyle = wall.color;
                this.ctx.lineWidth = wall.width;
                this.ctx.lineCap = 'square';
                
                this.ctx.beginPath();
                this.ctx.moveTo(wall.start.x, wall.start.y);
                this.ctx.lineTo(wall.end.x, wall.end.y);
                this.ctx.stroke();
            }
            
            redraw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawGrid();
                
                // ê¸°ì¡´ ë²½ë“¤ ê·¸ë¦¬ê¸°
                this.walls.forEach(wall => this.drawWall(wall));
                
                // ë¯¸ë¦¬ë³´ê¸° ë²½ ê·¸ë¦¬ê¸°
                if (this.previewWall) {
                    this.ctx.strokeStyle = this.previewWall.color;
                    this.ctx.lineWidth = this.previewWall.width;
                    this.ctx.globalAlpha = 0.7;
                    this.drawWall(this.previewWall);
                    this.ctx.globalAlpha = 1.0;
                }
            }
            
            setTool(tool) {
                this.currentTool = tool;
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                
                if (tool === 'wall') {
                    document.getElementById('wallTool').classList.add('active');
                    this.canvas.style.cursor = 'crosshair';
                } else if (tool === 'erase') {
                    document.getElementById('eraseTool').classList.add('active');
                    this.canvas.style.cursor = 'pointer';
                }
            }
            
            updateGridSize(e) {
                this.gridSize = parseInt(e.target.value);
                document.getElementById('gridSizeValue').textContent = this.gridSize + 'px';
                this.redraw();
            }
            
            updateWallWidth(e) {
                this.wallWidth = parseInt(e.target.value);
                document.getElementById('wallWidthValue').textContent = this.wallWidth + 'px';
            }
            
            updateWallColor(e) {
                this.wallColor = e.target.value;
            }
            
            clearCanvas() {
                if (confirm('ëª¨ë“  ê·¸ë¦¼ì„ ì§€ìš°ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                    this.walls = [];
                    this.redraw();
                }
            }
            
            loadTemplate() {
                if (confirm('ê¸°ë³¸ í…œí”Œë¦¿ì„ ë¶ˆëŸ¬ì˜¤ì‹œê² ìŠµë‹ˆê¹Œ? (í˜„ì¬ ê·¸ë¦¼ì€ ì§€ì›Œì§‘ë‹ˆë‹¤)')) {
                    this.walls = [];
                    
                    // ê¸°ë³¸ ë°© í…œí”Œë¦¿
                    const roomTemplate = [
                        // ì™¸ë²½
                        { start: {x: 100, y: 100}, end: {x: 500, y: 100}, color: '#2c3e50', width: 6 },
                        { start: {x: 500, y: 100}, end: {x: 500, y: 400}, color: '#2c3e50', width: 6 },
                        { start: {x: 500, y: 400}, end: {x: 100, y: 400}, color: '#2c3e50', width: 6 },
                        { start: {x: 100, y: 400}, end: {x: 100, y: 100}, color: '#2c3e50', width: 6 },
                        
                        // ë‚´ë²½
                        { start: {x: 300, y: 100}, end: {x: 300, y: 250}, color: '#34495e', width: 4 },
                        { start: {x: 100, y: 250}, end: {x: 500, y: 250}, color: '#34495e', width: 4 }
                    ];
                    
                    this.walls = roomTemplate;
                    this.redraw();
                }
            }
            
            saveDrawing() {
                // ë³„ë„ì˜ ìº”ë²„ìŠ¤ì— ê²©ì ì—†ì´ ë²½ë§Œ ê·¸ë¦¬ê¸°
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = this.canvas.width;
                exportCanvas.height = this.canvas.height;
                const exportCtx = exportCanvas.getContext('2d');
                
                // ì™„ì „íˆ ê¹¨ë—í•œ í°ìƒ‰ ë°°ê²½
                exportCtx.fillStyle = '#FFFFFF';
                exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
                
                // ì•ˆí‹°ì•¨ë¦¬ì–´ì‹± ë„ê¸° (ë” ì„ ëª…í•œ ì„ )
                exportCtx.imageSmoothingEnabled = false;
                
                // ë²½ë§Œ ê·¸ë¦¬ê¸° (ê²©ì ì™„ì „ ì œì™¸)
                if (this.walls && this.walls.length > 0) {
                    this.walls.forEach(wall => {
                        // ë²½ ìƒ‰ìƒì´ ê²©ì ìƒ‰ìƒê³¼ ë‹¤ë¥¸ì§€ í™•ì¸
                        if (wall.color !== '#ecf0f1' && wall.width > 1) {
                            exportCtx.strokeStyle = wall.color;
                            exportCtx.lineWidth = wall.width;
                            exportCtx.lineCap = 'square';
                            exportCtx.lineJoin = 'miter';
                            
                            exportCtx.beginPath();
                            exportCtx.moveTo(wall.start.x, wall.start.y);
                            exportCtx.lineTo(wall.end.x, wall.end.y);
                            exportCtx.stroke();
                        }
                    });
                } else {
                    console.log('ì €ì¥í•  ë²½ì´ ì—†ìŠµë‹ˆë‹¤.');
                }
                
                const link = document.createElement('a');
                link.download = 'floor_plan_clean.png';
                link.href = exportCanvas.toDataURL('image/png');
                link.click();
                
                // ë””ë²„ê·¸: ë²½ ê°œìˆ˜ ì¶œë ¥
                console.log('ì €ì¥ëœ ë²½ ê°œìˆ˜:', this.walls.length);
            }
        }
        
        // ì•± ì‹œì‘
        const editor = new FloorPlanEditor();
    </script>
</body>
</html>